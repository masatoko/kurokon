#!/user/bin/env stack
{- stack
  script
  --resolver lts-9.17
  --package split
  --package parsec
  --package extra
-}

{-# LANGUAGE RecordWildCards #-}

import           Debug.Trace            (trace, traceM)

import           Control.Monad          (forM_, when)
import           Data.Either.Extra      (fromRight)
import           Data.List              (intercalate, isPrefixOf)
import           Data.List.Split        (splitOn, splitWhen)
import           Data.Maybe             (isJust)
import           System.Environment     (getArgs)
import qualified System.IO              as IO
import           Text.Parsec
import           Text.Parsec.Char
import           Text.Parsec.Combinator
import           Text.Parsec.String     (Parser)

main :: IO ()
main = do
  (path:_) <- getArgs
  source <- readFile path
  let fs = convLines . lines $ source
  IO.withFile "../src/SDL/Raw/Primitive.hs" IO.WriteMode $ \hRaw -> do
    let put = IO.hPutStrLn hRaw
    put "module SDL.Raw.Primitive where"
    put ""
    put "-- Generated by 'scripts/makeffi.hs'"
    put ""
    put "import           Data.Int        (Int16)"
    put "import           Data.Word       (Word8, Word32)"
    put "import           Foreign.C.Types (CInt (..))"
    put "import           Foreign.Ptr     (Ptr)"
    put "import           SDL.Raw         (Renderer, Surface)"
    put ""
    forM_ fs $ \f ->
      when (funcName f `notElem` hiddenFuncs) $ do
        -- print f
        put $ funcToComment f
        put $ funcToFFI f
        put ""

data CType
  = Void
  | CInt
  | CChar
  | Renderer
  | Surface
  | Int16
  | Int32
  | Word8
  | Word32
  deriving (Eq, Show, Read)

data Arg = Arg
  { argConst :: Bool
  , argType  :: CType
  , argPtr   :: Bool
  , argName  :: String
  } deriving (Eq, Show, Read)

data Func = Func
  { funcName   :: String
  , returnType :: CType
  , arguments  :: [Arg]
  } deriving (Eq, Show, Read)

funcToComment :: Func -> String
funcToComment Func{..} =
  "-- | " ++ funcName ++ ": " ++ intercalate " -> " (map work arguments)
  where
    work Arg{..} =
      argName ++ "(" ++ cst ++ show argType ++ ptr ++ ")"
      where
        cst = if argConst then "const " else ""
        ptr = if argPtr then " *" else ""

funcToFFI :: Func -> String
funcToFFI Func{..} =
  "foreign import ccall unsafe \"" ++ funcName ++ "\" " ++ funcName ++ " :: "
    ++ intercalate " -> " (map argToFFI arguments) ++ " -> IO " ++ show returnType
  where
    argToFFI :: Arg -> String
    argToFFI Arg{..} = ptr ++ show argType
      where
        raw = argType == Renderer
        ptr
          | raw       = ""
          | argPtr    = "Ptr "
          | otherwise = ""

convLines :: [String] -> [Func]
convLines []  = []
convLines [a] = []
convLines (x:y:zs)
  | ('\t':kScope) `isPrefixOf` x =
      if endsFirstLine
        then func : convLines (y:zs)
        else func : convLines zs
  | otherwise = convLines (y:zs)
  where
    func = Func fname (convType rtype) args
    kScope = "SDL2_GFXPRIMITIVES_SCOPE "
    endsFirstLine = ';' `elem` x
    funcLine = filter (/= '\t') line
      where
        line
          | endsFirstLine = x
          | otherwise     = x ++ y
    (rtype:fname:_) = splitWhen (`elem` " (") $ drop (length kScope) funcLine
    --
    argPart = tail . dropWhile (/= '(') . takeWhile (/= ')') $ funcLine
    args = map work as
      where
        as = splitOn "," argPart
        work str = case parse arg "" str' of
                    Left err -> error $ show err
                    Right a  -> a
          where
            str' = dropWhile (== ' ') str

arg :: Parser Arg
arg =
  Arg <$> (isJust <$> optionMaybe (try (string "const ")))
      <*> (convType <$> many1 (alphaNum <|> char '_')) <* spaces
      <*> (isJust <$> optionMaybe (try (char '*' >> spaces)))
      <*> many1 (alphaNum <|> char '_')

convType :: String -> CType
convType "void"         = Void
convType "int"          = CInt
convType "char"         = CChar
convType "SDL_Renderer" = Renderer
convType "SDL_Surface"  = Surface
convType "Sint16"       = Int16
convType "Sint32"       = Int32
convType "Uint8"        = Word8
convType "Uint32"       = Word32
convType str            = error $ "undefined type: " ++ str

hiddenFuncs :: [String]
hiddenFuncs =
  [ "gfxPrimitivesSetFont"
  , "gfxPrimitivesSetFontRotation"
  , "characterColor"
  , "characterRGBA"
  , "stringColor"
  , "stringRGBA"
  ]
